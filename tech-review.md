JAX-RS
======

JAX-RS (ava API for RESTful Web Services) - стандарт, описывающий реализацию на Java RESTful веб-сервисов. 
Основная идея подхода REST состоит в том, что сервис представляется как набор ресурсов, идентифицированных 
уникальными URL. При этом поскольку в процессе существования сервися данные на нем постоянно изменяются: 
удалются прежние, добавляются новые и обновляются существующие, то и эти идентификаторы (пути, по которым происходят 
запросы) также являются динамическими. Например, они могут включать в себя уникальный идентификатор ресурса в базе, 
временной интервал для получения данных, созданных в указанный период, идентификатор пользователя-владельца этих ресурсов и пр.

JAX-RS предлагает простой подход для описания таких сервисов с использованием аннотаций. Ресурсом считается
любой класс или метод класса, аннотированный `@Path`. При этом путь, указываемый в аннотации может включать в себя
параметры пути (`@PathParam`), формат которых может быть дополнительно задан при помощи регулярных выражений. 

Помимо пути, к которому выполняется запрос клиентом, результат, получаемый от сервера, определяется также 
следующими факторами:

* HTTP методом: Например GET для получения данных, POST для внесения новых, PUT для обновления, DELETE для удаления 
(по аналогии с операциями CRUD). Для этого используются одноименные аннотации: `@GET`, `@POST`, `@PUT` и `@DELETE`

* Требуемым и передваемым форматами данных (заголовки Accept, Content-Type HTTP и соответсвующие аннотации `@Consume`, `@Provide` JAX-RS)

* Параметрами запроса, указываемыми в URL:
    - `@QueryParam` для параметров вида mysite.com/spam?foo=bar&foo=baz
    - `@MatrixParam` для параметров вида mysite.com/spam;foo=bar;foo=baz (фактически не используются)

* Самими данными, которые клиент передает на сервер в теле запроса

Важным на мой взгляд моментом является то, что RESTful сервис не обязательно подразумевает браузерный клиент, 
хотя это, пожалуй, наиболее распространенный обращения к таким сервисам. Фактически Jersey и не предаставляет никаких вспомогательных средств для создания динамических сайтов на базе REST - например, какого-либо движка темплейтов для генерации контента
динамических веб-страниц. RESTful сервис, созданный с использованием Jersey (или других реализаций JAX-RS) вполне может
использоваться исключительно как интерфейс для взаимодействия с СУБД в какой-нибудь распределнной системе. 
Клиенты при этом могут вообще не иметь никакого интерфейса, и, применительно, например, к системе тестирования
быть скриптами, отправляющими в базу статистику по тестам. Это очень простой путь для создания 
такого рода систем, так как HTTP - самый распространенный сетевой протокол, поддержка которого есть в стандартной 
библиотеке любого языка, а REST предоставляет естественный формат для использованя его для организации обмена произвольными данными
между клиентом и сервером.

JAXB
====

JAXB (Java Architecture for XML Binding) - технология, предоставлющая способ автоматической сериализации/десериализации классов в структурированные форматы данных: XML и JSON. Существует 2 стандартных сценария использования JAXB:

1. По формату предствления данных предметной области, заданному при помощи XML Schema, посредством утилиты `xjc` или, например, 
плагина Maven, генерируются классы, объектами которыми эти данные могут быть представлены в программе (классами представлюятся 
элементы `xsd:complexType` предоствленной схемы). 
При этом неоходимо учесть следующее:

    * Классы не описывают всех ограничений схемы. Например, `xsd:sequence` преобразуется в поле типа `List<Object>`, в которое может
    быть добавлено произвольное число элементов и в произвольном порядке. Ограничения на простые типы, например, диапазон допустимых значений поля, представленного типом `xsd:int`, также не учитываются при конструировании объектов, сгенерированных по схеме.
    Для того, чтобы полностью проверить в допустимость входных данных, в JAXB следует явно указать схему для объекта класса `Unmarshaller`, осуществляющего создание объектов, описанных в XML.

    * Существует возможность для кастомизации генерируемых классов при помощи аннотаций (тег `xsd:annotation`) внутри самой схемы,
    либо внешнего *binding* файла. Например, таким образом можно переопределить названия генерируемых `xjc` полей и классов.  

2. Специальные аннотации JAXB вносятся в определения уже существующих классов, для описания того, как они могут быть преобразованы 
в/из XML/JSON. Недостаток такого подхода в том, что, во-первых, задача проверки корректности входных данных переносится на разработчика , во-вторых, если все же используется схема для проверки данных, их описание начинает дублироваться как в программе, так и в самой схеме, в-третьих, с помощью схемы формат данных описывается более строго, ее проще изменять, к тому же она может быть повторно использована, в отличии от аннотаций в классах.

Одним из "тонких" моментов JAXB, на мой взгляд, является то, что некоторые теги входного XML документа преобразуются 
непосредственно в классы, соответствующие описанным с схеме составным типам (`xsd:complexType`), другие - в объекты 
типа `JAXBElement<T>`. В объект класса `JAXBElement<T>` помимо десерилизованного содержимого тега (дочерние элементы и атрибуты), 
также входит его имя. Происходит это потому, что иногда типу однозначно соответствуют имя элемента (например, в случае если
тип был задан, как анонимный (*inlined*) для элемента), в других случаях одному типу может соответствовать несколько различных тегов
и тогда требуется имя для того, чтобы однозначно идентифицировать элемент. В первом случае, если к тому же элемент был 
описан на верхнем уровне схемы, тип аннотируется как `@XMLRootElement`, то есть может быть возвращен в результате разбора 
документа.

Для упрощения создания объектов сгенерированных классов `xjc` также создает класс `ObjectFactory`, предоставлющий набор 
соответсвующих методов-фабрик.

WADL
====

WADL (Web Application Descriptive Language) - стандарт описания RESTful веб-сервисов с посредством XML. Например, Jersey генирует такой документ при при осуществлении

1. GET запроса по адресу `{resource-url}/application.wadl`
2. OPTIONS запроса на адрес конкретного ресурса

WADL-описание сервиса может быть использовано несколькими способами. Во-первых, клиент может получить информацию о том, какие ресурсы предоставляет сервис и как с ними взаимодействовать. Во-вторых, по WADL-описанию сервиса можно синтезировать простую клиентскую часть для взаимодействия с сервисом с использованием Jersey Client API, что удобно, например, при тестировании системы. Для этого может быть использована либо утилита `wadl2java`, либо Maven плагин `wadl-client-plugin`.

