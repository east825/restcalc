JAX-RS
======

JAX-RS - стандарт, описывающий реализацию на Java RESTful веб-сервисов. Основная идея таких сервисов 
состоит в том, что сервис представляется как набор ресурсов, идентифицированных уникальными URL. При этом 
поскольку в процессе существования сервися данные на нем постоянно изменяются: удалются прежние, добавляются 
новые и обновляются существующие, то и эти идентификаторы (пути, по которым происходят запросы) также являются
динамическими. Например, они могут включать в себя уникальный идентификатор ресурса в базе, временной интервал
для получения данных, созданных в указанный период, идентификатор пользователя-владельца этих ресурсов и пр.

JAX-RS предлагает простой подход для описания таких сервисов с использованием аннотаций. Ресурсом считается
любой класс или метод класса, аннотированный `@Path`. При этом путь, указываемый в аннотации может включать в себя
параметры пути (`@PathParam`), формат которых может быть задан при помощи регулярных выражений. 

Помимо пути, к которому выполняется запрос клиентом, результат, получаемый от сервера, определяется также 
следующими факторами:

* HTTP методом: Например GET для получения данных, POST для внесения новых, PUT для обновления, DELETE для удаления 
(по аналогии с CRUD). Для этого используются одноименные аннотации: `@GET`, `@POST`, `@PUT` и `@DELETE`

* Требуемым и передваемым форматами данных (заголовки Accept, Content-Type HTTP и аннотации`@Consume`, `@Provide` JAX-RS)

* Параметрами запроса, указываемыми в URL:
    - `@QueryParam` для параметров вида mysite.com/spam?foo=bar&foo=baz
    - `@MatrixParam` для параметров вида mysite.com/spam;foo=bar;foo=baz (фактически не используются)

* Самими данными, которые клиент передает на сервер в теле запроса

Важным на мой взгляд моментом является то, что RESTful сервис не обязательно подразумевает браузерный клиент, 
хотя это, пожалуй, наиболее распространенный сценарий. Фактически Jersey и не предаставляет никаких вспомогательных 
средств для создания динамических сайтов на базе REST - например, какого-либо движка темплейтов для генерации контента
веб-страниц. То есть RESTful сервис, созданный с использованием Jersey (или других реализаций JAX-RS) вполне может
использоваться исключительно как интерфейс для взаимодействия с СУБД в какой-нибудь распределнной системе. 
Клиенты при этом могут вообще не иметь никакого интерфейса, и, применительно, например, к системе тестирования
быть скриптами на Python или Bash, отправляющими в базу статистику по тестам. Это очень простой путь для создания 
такого рода систем, так как HTTP - самый распространенный сетевой протокол, поддержка которого есть в стандартной 
библиотеке любого языка, а REST предоставляет естественный формат для использованя его для организации обмена произвольными данными
между клиентом и сервером.

JAXB
====

JAXB - технология, предоставлющая способ автоматической сериализации/десериализации классов в структурированные форматы данных:
XML и JSON. Это может быть осуществленно двумя способами:

1. По формату предствления данных предметной области, заданному при помощи XML Schema, посредством утилиты `xjc` или, например, 
плагина Maven, генерируются классы, объектами которыми эти данные могут быть представлены в программе (классами представлюятся 
элементы `xsd:complexType` предоствленной схемы). 
При этом неоходимо учесть следующее:

    * Классы не описывают всех ограничений схемы. Например, `xsd:sequence` преобразуется в поле типа `List<Object>`, в которое может
    быть добавлено произвольное число элементов. Ограничения на простые типы, например, диапазон допустимых значений поля,
    представленного типом `xsd:int`, также не учитываются при конструировании или десериализации объектов, сгенерированных по схеме.
    Для того чтобы, проверить допустимость входных данных, следует явно задать схему для объекта класса `Unmarshaller`, осуществляющего
    обратное преобрзование.

    * Существует возможность для кастомизации генерируемых классов при помощи аннотаций (тег `xsd:annotation`) внутри самой схемы,
    либо внешнего *binding* файла. Например, таким образом можно задать названия генерируемых полей и классов.  

2. Специальным аннотации JAXB вносятся в определения уже существующих классов, для описания того, как они могут быть оттранслированы 
в XML/JSON.

Одним из "тонких" моментов JAXB, на мой взгляд, является то, что некоторые теги входного XML документа преобразуются 
непосредственно в классы, соответствующие описанным с схеме составным типам (`xsd:complexType`), другие - в объекты 
типа `JAXBElement<T>`. В класс `JAXBElement<T>` помимо десерилизованного содержимого тега (дочерние элементы и атрибуты), 
также входит его имя. Происходит это потому, что иногда типу однозначно соответствуют имя элемента (например, в случае если
тип был задан, как анонимный (inlined) для элемента), в других случаях одному типу может соответствовать несколько различных тегов
и тогда требуется имя для того, чтобы однозначно идентифицировать элемент. В первом случае, если к тому же элемент был 
описан на верхнем уровне схемы, тип аннотируется как `@XMLRootElement`, то есть может быть возвращен в результате разбора 
документа.

Для упрощения создания объектов сгенерированных классов `xjc` также создает класс `ObjectFactory`, предоставлющий набор 
соответсвующих методов-фабрик.

WADL
====

